package DataStructure.tree;

/**
 * TODO
 *  完全二叉树、平衡二叉树、二叉查找树
 * 概念: 3层树
 *      1               2^0
 *
 *    *   *
 *   2     3            2^1
 *  * *   * *
 * 4   5 6   7          2^2
 *                      2^3
 *                      2^4
 *         第k层        2^(k-1)
 *
 * 节点的度：结点拥有的子树数目称为结点的度，叶子结点 就是度为0的结点
 * 树的度：树内各结点的度的最大值
 * 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
 * 树的高度或深度：树中节点的最大层次； 如上图：树的高度为3
 *
 * 二叉树的特点：
 *
 * 1. 每个结点最多有两棵子树，即二叉树不存在度大于2的结点。
 * 2. 二叉树的子树有左右之分，其子树的次序不能颠倒。
 /**
 *              满二叉树
 * 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是
 * 说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。
 * 等比数列
 * 1(2^k-1)= (2^k) -1
 *              完全二叉树
 * 所有叶子节点都出现在 k 或者 k-1 层，而且从 1 到 k-1 层必须达到最大节点数；
 * 第 k 层可以不是满的，但是第 k 层的所有节点必须集中在最左边。
 * 完全二叉树不要求所有树都有左右子树，
 *
 * 当我们用数组实现一个完全二叉树时，
 * 叶子节点可以按从上到下、从左到右的顺序依次添加到数组中，
 * 然后知道一个节点的位置，就可以轻松地算出它的父节点、孩子节点的位置。
 * 叶子节点出现在最后一层或者倒数第二层，不能再往上
 * 比如节点2
 * 父节点就是 (k/2 = 1)
 * 子节点分别是 (2k=4) 和 (2k+1=5)
 *              二叉查找树
 * 二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
 *
 * 1。若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
 *
 * 2。若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
 *
 * 左、右子树也分别为二叉排序树。
 * ！！！二叉排序树的中序遍历一定是从小到大的。
 *
 *  为了保证二叉排序树不出现一个链表的极端情况（插入的元素是有序的，导致变成一个链表），就可以保证很高的效率了。
 *              平衡二叉树
 * 为了保证树不至于太倾斜，尽量保证两边平衡。因此它的定义如下：
 * 平衡二叉树要么是一棵空树
 *
 * 要么保证左右子树的高度之差不大于 1
 * 子树也必须是一颗平衡二叉树
 */

public class TreeNode {

    // 左节点(儿子)
    public TreeNode left;

    // 右节点(儿子)
    public TreeNode right;

    // 数据
    public Integer val;

    public TreeNode(Integer val) {

        this.val = val;
    }


}
